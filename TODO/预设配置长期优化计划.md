# 预设配置长期优化计划

## 当前实现状态（v1.0）

### ✅ 已实现
- **用户配置优先策略**：用户自定义配置始终优先于预设配置
- **预设配置文件**：`default-configs.js` 包含主流AI网站的预设选择器
- **配置来源标识**：界面清晰显示"✏️ 自定义"或"⚙️ 预设"
- **重置为预设功能**：用户可以删除自定义配置，恢复使用预设
- **动态合并机制**：运行时从用户配置和预设配置中动态合并

### 工作流程
```
用户访问网站
  ↓
1. 读取用户自定义配置 (chrome.storage.local)
2. 读取预设配置 (default-configs.js)
3. 合并策略：
   - 有用户配置 → 使用用户配置 ✅
   - 无用户配置，有预设 → 使用预设 ✅
   - 都没有 → 使用通用选择器 ✅
```

## 长期优化方向（v2.0+）

### 1. 分层策略 - 版本比较与主动通知

#### 目标
当预设配置更新时，主动通知用户有更好的配置可用。

#### 设计方案

##### 1.1 版本跟踪
```javascript
// default-configs.js - 预设配置增加版本号
const DEFAULT_CONFIGS = {
  'chat_deepseek_com': {
    inputSelector: 'textarea',
    sendButtonSelector: 'button[type="submit"]',
    version: '2025-01-19',  // 配置版本
    changeLog: 'Initial version' // 变更说明
  }
};

// 用户配置也记录版本
userConfigs['chat_deepseek_com'] = {
  inputSelector: 'textarea.custom',
  sendButtonSelector: 'button.send',
  version: '2025-01-10',  // 用户配置时间
  source: 'user',
  basedOnPresetVersion: '2025-01-05'  // 基于哪个预设版本
};
```

##### 1.2 版本比较逻辑
```javascript
async function loadSiteConfig() {
  const userConfig = userConfigs[siteId];
  const presetConfig = DEFAULT_CONFIGS[siteId];
  
  if (userConfig && presetConfig) {
    // 比较版本
    const presetDate = new Date(presetConfig.version);
    const userDate = new Date(userConfig.basedOnPresetVersion || userConfig.version);
    
    if (presetDate > userDate) {
      // 预设配置更新了！
      await notifyConfigUpdate(siteId, {
        currentConfig: userConfig,
        newPresetConfig: presetConfig,
        improvements: presetConfig.changeLog
      });
    }
  }
  
  // 继续使用用户配置（不强制更新）
  return userConfig || presetConfig;
}
```

##### 1.3 通知机制
```javascript
// 在split-view或配置页面显示通知横幅
async function notifyConfigUpdate(siteId, { currentConfig, newPresetConfig, improvements }) {
  const notification = {
    type: 'config-update',
    siteId: siteId,
    siteName: newPresetConfig.name,
    currentVersion: currentConfig.version,
    newVersion: newPresetConfig.version,
    improvements: improvements,
    timestamp: Date.now()
  };
  
  // 存储到待处理通知列表
  await chrome.storage.local.set({
    pendingConfigUpdates: [notification]
  });
  
  // 在配置页面显示通知横幅
  showUpdateBanner(notification);
}

function showUpdateBanner(notification) {
  const banner = document.createElement('div');
  banner.className = 'config-update-banner';
  banner.innerHTML = `
    <div class="banner-icon">🆕</div>
    <div class="banner-content">
      <h4>${notification.siteName} 有新的推荐配置</h4>
      <p>版本: ${notification.currentVersion} → ${notification.newVersion}</p>
      <p>改进: ${notification.improvements}</p>
    </div>
    <div class="banner-actions">
      <button class="btn-view-diff">查看差异</button>
      <button class="btn-apply-preset">应用新预设</button>
      <button class="btn-keep-current">保持现有</button>
    </div>
  `;
  
  document.body.prepend(banner);
}
```

##### 1.4 应用更新
```javascript
async function applyPresetUpdate(siteId) {
  const presetConfig = DEFAULT_CONFIGS[siteId];
  
  // 备份用户配置
  const backup = { ...userConfigs[siteId] };
  await chrome.storage.local.set({
    [`configBackup_${siteId}`]: backup
  });
  
  // 应用预设配置
  userConfigs[siteId] = {
    ...presetConfig,
    source: 'preset-applied',
    appliedAt: Date.now(),
    previousUserConfig: backup
  };
  
  await saveConfigs();
  
  // 显示成功提示
  showNotification('✅ 已应用新预设配置', 'success');
}
```

### 2. 字段级合并

#### 目标
用户只配置部分字段（如输入框），其他字段（如发送按钮）自动使用预设。

#### 实现方案
```javascript
function getSiteConfig(siteId) {
  const userConfig = userConfigs[siteId];
  const presetConfig = DEFAULT_CONFIGS[siteId];
  
  if (!userConfig) return presetConfig;
  if (!presetConfig) return userConfig;
  
  // 字段级合并
  return {
    // 输入框：用户配置优先
    inputSelector: userConfig.inputSelector || presetConfig.inputSelector,
    inputSelectorSource: userConfig.inputSelector ? 'user' : 'preset',
    
    // 发送按钮：用户配置优先
    sendButtonSelector: userConfig.sendButtonSelector || presetConfig.sendButtonSelector,
    sendButtonSelectorSource: userConfig.sendButtonSelector ? 'user' : 'preset',
    
    // 元数据
    version: userConfig.version,
    presetVersion: presetConfig.version,
    source: 'merged'
  };
}
```

#### 配置界面展示
```javascript
// 在配置页面显示详细来源
<div class="config-detail">
  <div class="config-field">
    <label>输入框选择器</label>
    <code>${config.inputSelector}</code>
    <span class="source-badge ${config.inputSelectorSource}">
      ${config.inputSelectorSource === 'user' ? '自定义' : '预设'}
    </span>
  </div>
  
  <div class="config-field">
    <label>发送按钮选择器</label>
    <code>${config.sendButtonSelector}</code>
    <span class="source-badge ${config.sendButtonSelectorSource}">
      ${config.sendButtonSelectorSource === 'user' ? '自定义' : '预设'}
    </span>
  </div>
</div>
```

### 3. 智能配置验证

#### 目标
定期验证配置是否有效，失效时自动切换到预设或通知用户。

#### 实现方案
```javascript
// 在iframe-injector.js中验证配置
async function validateConfig(siteConfig) {
  const inputElement = document.querySelector(siteConfig.inputSelector);
  const sendButton = document.querySelector(siteConfig.sendButtonSelector);
  
  const isValid = !!(inputElement && sendButton && 
                     isVisible(inputElement) && isVisible(sendButton));
  
  if (!isValid) {
    console.warn('⚠️ 配置验证失败，选择器可能已失效');
    
    // 记录失败
    await chrome.storage.local.set({
      [`configValidation_${siteId}`]: {
        isValid: false,
        lastChecked: Date.now(),
        failureCount: (previousFailureCount || 0) + 1
      }
    });
    
    // 如果失败次数超过阈值，通知用户
    if (failureCount >= 3) {
      notifyConfigFailure(siteId);
    }
  }
  
  return isValid;
}
```

### 4. 云端配置同步（可选）

#### 目标
用户在不同设备间同步配置，并且获取社区维护的最新配置。

#### 实现方案
```javascript
// 使用chrome.storage.sync自动同步
await chrome.storage.sync.set({
  userConfigs: allConfigs
});

// 或者建立云端配置服务器
async function fetchLatestPresets() {
  const response = await fetch('https://api.example.com/presets/latest');
  const cloudPresets = await response.json();
  
  // 合并云端预设和本地预设
  return { ...DEFAULT_CONFIGS, ...cloudPresets };
}
```

## 实施优先级

### P0 - 当前版本（已完成）
- ✅ 基础预设配置文件
- ✅ 用户配置优先策略
- ✅ 配置来源标识
- ✅ 重置为预设功能

### P1 - 下个版本（v2.0）
- 🔜 版本比较机制
- 🔜 配置更新通知
- 🔜 字段级合并

### P2 - 未来版本（v3.0）
- 📋 智能配置验证
- 📋 配置备份和恢复
- 📋 差异对比界面

### P3 - 长远规划
- 📋 云端配置同步
- 📋 社区配置分享
- 📋 配置自动修复

## 技术债务和注意事项

### 数据迁移
如果更改配置结构，需要提供迁移脚本：
```javascript
async function migrateConfigs() {
  const oldConfigs = await chrome.storage.local.get(['aiSelectorConfigs']);
  
  const newConfigs = {};
  for (const [id, config] of Object.entries(oldConfigs.aiSelectorConfigs || {})) {
    newConfigs[id] = {
      ...config,
      version: config.version || '2025-01-01',  // 添加默认版本
      source: config.source || 'user'
    };
  }
  
  await chrome.storage.local.set({ aiSelectorConfigs: newConfigs });
}
```

### 性能考虑
- 版本比较不要在每次页面加载时都执行，使用缓存
- 通知不要过于频繁，设置冷静期（如7天内不重复通知）

### 用户体验
- 通知要友好，不要强制用户更新
- 提供"不再提示"选项
- 差异对比要直观，使用可视化界面

## 参考资料

- Chrome Extension Storage API: https://developer.chrome.com/docs/extensions/reference/storage/
- Semantic Versioning: https://semver.org/
- 配置管理最佳实践: https://12factor.net/config

---

**文档版本**: 1.0  
**最后更新**: 2025-01-19  
**负责人**: 待定  
**审核状态**: 待审核

