# 架构重构 - 策略模式设计

## 🎯 用户反馈

> "不止是这个发送按钮，其他的策略也需要灵活而不是写死，要解决一类问题，而不是单个case的解决"

**这是非常深刻的架构思维！** 🎖️

## ❌ 当前的问题

### 1. **散落各处的硬编码判断**

**填充输入框** (iframe-injector.js:334):
```javascript
if (element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
  // TEXTAREA逻辑
} else if (element.isContentEditable) {
  // ContentEditable逻辑
} else if (element.classList.contains('ql-editor')) {
  // Quill逻辑
}
```

**点击按钮** (iframe-injector.js:76):
```javascript
sendButton.dispatchEvent(new MouseEvent('mousedown'));
sendButton.dispatchEvent(new MouseEvent('mouseup'));
sendButton.dispatchEvent(new PointerEvent('pointerdown'));
// ... 一堆硬编码的事件
```

**查找元素** (iframe-injector.js:122):
```javascript
const selectors = [
  '#prompt-textarea',  // 硬编码！
  '.ql-editor',        // 硬编码！
  // ... 50+行硬编码的选择器
];
```

### 2. **问题本质**

- ❌ **补丁思维**：遇到新网站 → 加if判断 → 加选择器 → 无限膨胀
- ❌ **case by case**：每次只解决一个具体问题
- ❌ **不可扩展**：添加新策略需要修改核心代码
- ❌ **难以测试**：逻辑散落，无法独立测试
- ❌ **难以维护**：一个bug可能影响所有网站

## ✅ 新架构：策略模式

### 核心思想

> **"把'做什么'和'怎么做'分离"**

- **做什么**：填充输入、触发点击、查找元素 ← 稳定的接口
- **怎么做**：各种策略 ← 可配置、可扩展

### 架构图

```
┌─────────────────────────────────────────────────┐
│         interaction-strategies.js                │
│         (策略配置中心)                            │
├─────────────────────────────────────────────────┤
│  INPUT_FILL_STRATEGIES   (输入填充策略组)        │
│  ├─ 原生Setter策略                               │
│  ├─ ContentEditable策略                          │
│  ├─ ExecCommand策略                              │
│  ├─ Quill编辑器策略                              │
│  └─ 通用降级策略                                  │
├─────────────────────────────────────────────────┤
│  CLICK_TRIGGER_STRATEGIES  (点击触发策略组)      │
│  ├─ 聚焦策略                                      │
│  ├─ 鼠标事件序列                                  │
│  ├─ 指针事件序列                                  │
│  ├─ 触摸事件序列                                  │
│  └─ 原生Click                                     │
├─────────────────────────────────────────────────┤
│  ELEMENT_FIND_STRATEGIES  (元素查找策略)         │
│  ├─ inputFeatures  (输入框特征列表)              │
│  └─ buttonFeatures (按钮特征列表)                │
├─────────────────────────────────────────────────┤
│  StrategyExecutor  (策略执行引擎)                │
│  ├─ fillInput()   - 执行所有适用的填充策略        │
│  ├─ clickButton() - 执行所有点击策略              │
│  ├─ isInputElement() - 基于特征判断输入框        │
│  └─ isButtonElement() - 基于特征判断按钮         │
└─────────────────────────────────────────────────┘
                    ↓ 使用
┌─────────────────────────────────────────────────┐
│         iframe-injector.js                       │
│         (业务逻辑层)                              │
├─────────────────────────────────────────────────┤
│  fillAndSend(text) {                             │
│    const input = findInputElement();             │
│    StrategyExecutor.fillInput(input, text); ←调用│
│                                                   │
│    const button = findSendButton();              │
│    StrategyExecutor.clickButton(button);   ←调用 │
│  }                                                │
└─────────────────────────────────────────────────┘
```

## 🔧 策略模式详解

### 1. **输入填充策略**

每个策略包含：
- `name`: 策略名称
- `condition`: 适用条件（可选）
- `execute`: 执行逻辑

```javascript
{
  name: '原生Setter策略',
  condition: (element) => element.tagName === 'TEXTAREA' || element.tagName === 'INPUT',
  execute: (element, text) => {
    const setter = Object.getOwnPropertyDescriptor(prototype, 'value')?.set;
    if (setter) {
      setter.call(element, text);
      return true; // 成功
    }
    return false; // 失败
  }
}
```

**执行流程**：
```
StrategyExecutor.fillInput(element, text)
  ↓
1. 遍历 INPUT_FILL_STRATEGIES
2. 检查 condition (如果有)
3. 执行 execute
4. 记录结果
5. 继续下一个策略（不中断！）
  ↓
触发所有输入事件
```

**优势**：
- ✅ 所有策略都会尝试（不会因为一个失败就放弃）
- ✅ 新增策略只需添加对象到数组
- ✅ 可以独立测试每个策略
- ✅ 可以动态禁用/启用策略

### 2. **点击触发策略**

```javascript
const CLICK_TRIGGER_STRATEGIES = [
  {
    name: '鼠标事件序列',
    execute: (element) => {
      const events = ['mouseover', 'mouseenter', 'mousedown', 'mouseup', 'click'];
      events.forEach(eventName => {
        element.dispatchEvent(new MouseEvent(eventName, options));
      });
    }
  },
  {
    name: '指针事件序列',
    execute: (element) => {
      // ...
    }
  }
];
```

**执行流程**：
```
StrategyExecutor.clickButton(element)
  ↓
遍历所有策略并执行
  ↓
返回执行结果
```

### 3. **元素识别策略**

**基于特征而非标签**：

```javascript
const ELEMENT_FIND_STRATEGIES = {
  inputFeatures: [
    { name: 'tagName', check: (el) => ['TEXTAREA', 'INPUT'].includes(el.tagName) },
    { name: 'contentEditable', check: (el) => el.isContentEditable },
    { name: 'role', check: (el) => el.getAttribute('role') === 'textbox' },
    { name: 'quillEditor', check: (el) => el.classList.contains('ql-editor') }
  ],
  
  buttonFeatures: [
    { name: 'tagName', check: (el) => el.tagName === 'BUTTON' },
    { name: 'role', check: (el) => el.getAttribute('role') === 'button' },
    { name: 'cursorPointer', check: (el) => getComputedStyle(el).cursor === 'pointer' }
  ]
};

// 使用
StrategyExecutor.isInputElement(element);
// 返回: ['tagName', 'role'] - 匹配的特征列表
```

## 📊 对比：补丁思维 vs 架构思维

| 维度 | 补丁思维 | 架构思维 (策略模式) |
|------|---------|---------------------|
| **新问题** | 加if判断 | 加策略对象 |
| **代码位置** | 散落各处 | 集中配置文件 |
| **扩展性** | 修改核心代码 | 添加配置 |
| **测试** | 难以隔离 | 独立测试每个策略 |
| **维护** | 牵一发动全身 | 策略独立 |
| **可读性** | if/else嵌套 | 声明式配置 |
| **灵活性** | 写死 | 可动态调整 |

## 🎯 实际案例

### 案例1：支持新的Markdown编辑器

**补丁思维**：
```javascript
// ❌ 修改iframe-injector.js核心代码
if (element.classList.contains('ql-editor')) {
  // Quill逻辑
} else if (element.classList.contains('CodeMirror')) {  // 新加
  // CodeMirror逻辑  // 新加
}
```

**架构思维**：
```javascript
// ✅ 只在interaction-strategies.js添加策略
INPUT_FILL_STRATEGIES.push({
  name: 'CodeMirror编辑器策略',
  condition: (el) => el.classList.contains('CodeMirror'),
  execute: (el, text) => {
    el.CodeMirror.setValue(text);
    return true;
  }
});
```

**无需修改任何业务代码！**

### 案例2：AI网站要求必须按Ctrl+Enter发送

**补丁思维**：
```javascript
// ❌ 修改点击逻辑
if (某个特定网站) {
  // 按Ctrl+Enter
} else {
  // 普通点击
}
```

**架构思维**：
```javascript
// ✅ 添加新策略
CLICK_TRIGGER_STRATEGIES.push({
  name: 'Ctrl+Enter组合键',
  execute: (element) => {
    element.dispatchEvent(new KeyboardEvent('keydown', {
      key: 'Enter',
      ctrlKey: true,
      bubbles: true
    }));
  }
});
```

**自动应用到所有网站！**

### 案例3：某网站输入框需要特殊的focus事件

**补丁思维**：
```javascript
// ❌ 在fillInput里加判断
if (element.matches('.special-input')) {
  element.dispatchEvent(new FocusEvent('focus', {special: true}));
}
```

**架构思维**：
```javascript
// ✅ 添加事件触发策略
EVENT_TRIGGER_STRATEGIES.push({
  name: '特殊Focus事件',
  events: ['focus'],
  createEvent: (eventName) => {
    return new FocusEvent(eventName, {
      bubbles: true,
      cancelable: true,
      composed: true  // 特殊参数
    });
  }
});
```

## 🚀 扩展能力

### 1. **用户自定义策略**（未来）

```javascript
// 用户在配置页面添加自定义策略
{
  "name": "我的AI助手专用策略",
  "condition": "element.classList.contains('my-ai-input')",
  "execute": "element.myCustomMethod(text);"
}
```

### 2. **策略优先级**（未来）

```javascript
{
  name: '高优先级策略',
  priority: 10,  // 数字越大越优先
  execute: (el, text) => { ... }
}
```

### 3. **策略组合**（未来）

```javascript
{
  name: '组合策略',
  strategies: ['策略A', '策略B'],  // 引用其他策略
  executeMode: 'all' | 'first-success'  // 执行模式
}
```

### 4. **条件策略链**（未来）

```javascript
{
  name: '条件策略链',
  chain: [
    { condition: (el) => el.tagName === 'TEXTAREA', strategy: '策略A' },
    { condition: (el) => el.isContentEditable, strategy: '策略B' },
    { default: '通用策略' }
  ]
}
```

## 📋 迁移计划

### Phase 1: 创建策略配置文件 ✅
- `interaction-strategies.js`
- 定义所有策略

### Phase 2: 重构iframe-injector.js
- 引入StrategyExecutor
- 替换硬编码逻辑

### Phase 3: 重构element-picker.js
- 使用特征判断替代标签判断

### Phase 4: 添加配置UI（可选）
- 让用户在配置页面禁用/启用策略
- 调整策略执行顺序

## 💡 设计原则总结

### 1. **策略模式 (Strategy Pattern)**
> 定义一系列算法，把它们封装起来，并使它们可相互替换

### 2. **开放封闭原则 (Open-Closed Principle)**
> 对扩展开放，对修改封闭

### 3. **单一职责原则 (Single Responsibility)**
> 每个策略只做一件事

### 4. **依赖倒置原则 (Dependency Inversion)**
> 依赖抽象（StrategyExecutor），不依赖具体实现

### 5. **组合优于继承 (Composition over Inheritance)**
> 策略可以组合使用，不需要复杂的继承体系

## 🎯 核心价值

### 之前：解决Case
```
遇到问题 → 加if判断 → 临时解决 → 技术债累积
```

### 现在：解决类
```
定义策略接口 → 添加策略实现 → 自动应用 → 可持续发展
```

---

## 📚 参考资料

- **设计模式**: 策略模式、工厂模式
- **架构原则**: SOLID原则
- **最佳实践**: 声明式编程、配置驱动

---

**更新时间**: 2025-10-17  
**版本**: v2.0.0 架构重构  
**核心**: 从"解决问题"到"解决类问题"

